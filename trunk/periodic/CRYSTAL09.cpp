#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <iostream>
#include <cstring>
#include <fstream>
#include <mpi.h>

//#include "mycomplex.h"
#include "mylogical.h"
//#include "conversion_factors.h"
#include "USER_DATA.h"
//#include "MATRIX_UTIL.h"
#include "myconstants.h"
#include "TOOLS.h"
//#include "PARALLEL.h"
#include "KPOINTS.h"
//#include "MEMORY.h"
#include "CRYSTAL09.h"

using namespace std;

  // ******************************************************************************************
  // * All utilities for reading data from CRYAPI interface to CRYSTAL09 are here             *
  // ******************************************************************************************

void read_SYMMOP_crystal_09(SYMMETRY *symmetry, JOB_PARAM *job, FILES file)

{

  // ******************************************************************************************
  // * Read symmetry operators from CRYSTAL09 replacing operators generated by EXCITON        *
  // ******************************************************************************************

  int i, tmp, tmp1;
  char line[151];

  FILE *SYMM;
  SYMM = fopen("SYMMOP", "r");
  if (SYMM == NULL) { fprintf(stderr, "ERROR: Cannot open file 'SYMMOP'. \n"); exit(1); }

  for (i = 0; i < symmetry->number_of_operators; i++) {
  read_line(SYMM, line, 150); // read title
  sscanf(line, "%d %d", &tmp, &tmp1);
  symmetry->inverse[i] = tmp1 - 1;
  read_line(SYMM, line, 150); // read title
  sscanf(line, "%lf %lf %lf", &symmetry->irr[9 * i + 0], &symmetry->irr[9 * i + 1], &symmetry->irr[9 * i + 2]);
  read_line(SYMM, line, 150); // read title
  sscanf(line, "%lf %lf %lf", &symmetry->irr[9 * i + 3], &symmetry->irr[9 * i + 4], &symmetry->irr[9 * i + 5]);
  read_line(SYMM, line, 150); // read title
  sscanf(line, "%lf %lf %lf", &symmetry->irr[9 * i + 6], &symmetry->irr[9 * i + 7], &symmetry->irr[9 * i + 8]);
  read_line(SYMM, line, 150); // read title
  sscanf(line, "%lf %lf %lf", &symmetry->taur[i].comp1, &symmetry->taur[i].comp2, &symmetry->taur[i].comp3);
 }

  for (i = 0; i < symmetry->number_of_operators; i++) {
  read_line(SYMM, line, 150); // read title
  sscanf(line, "%d %d %d %d %d %d %d %d %d", &symmetry->inr[9 * i + 0], &symmetry->inr[9 * i + 1], &symmetry->inr[9 * i + 2], \
                                             &symmetry->inr[9 * i + 3], &symmetry->inr[9 * i + 4], &symmetry->inr[9 * i + 5], \
                                             &symmetry->inr[9 * i + 6], &symmetry->inr[9 * i + 7], &symmetry->inr[9 * i + 8]);
 }

        if (job->taskid == 0) {
        fprintf(file.out,"===========================================================================================================\n");
        fprintf(file.out,"|                              SYMMETRY OPERATORS READ FROM CRYSTAL09                                     |\n");
        fprintf(file.out,"===========================================================================================================\n");
       }

    if (job->taskid == 0 && job->verbosity > 1) {

    fprintf(file.out, "                                %2d SYMMETRY OPERATORS\n\n", symmetry->number_of_operators);
    for (i = 0; i < symmetry->number_of_operators; i++)
          fprintf(file.out,"%3d %3d\n %5.2lf %5.2lf %5.2lf     %5.2lf\n %5.2lf %5.2lf %5.2lf     %5.2lf \n %5.2lf %5.2lf %5.2lf     %5.2lf\n",
          i + 1, symmetry->inverse[i] + 1, symmetry->irr[i * 9 + 0], symmetry->irr[i * 9 + 1], symmetry->irr[i * 9 + 2], symmetry->taur[i].comp1, \
                 symmetry->irr[i * 9 + 3], symmetry->irr[i * 9 + 4], symmetry->irr[i * 9 + 5], symmetry->taur[i].comp2, \
                 symmetry->irr[i * 9 + 6], symmetry->irr[i * 9 + 7], symmetry->irr[i * 9 + 8], symmetry->taur[i].comp3);
    fprintf(file.out, "\n");

    fprintf(file.out, "                                %2d SYMMETRY OPERATORS\n\n", symmetry->number_of_operators);
    for (i = 0; i < symmetry->number_of_operators; i++)
          fprintf(file.out,"%3d %3d\n %5d %5d %5d\n %5d %5d %5d\n %5d %5d %5d\n",
          i + 1, symmetry->inverse[i] + 1, symmetry->inr[i * 9 + 0], symmetry->inr[i * 9 + 1], symmetry->inr[i * 9 + 2], \
                 symmetry->inr[i * 9 + 3], symmetry->inr[i * 9 + 4], symmetry->inr[i * 9 + 5], \
                 symmetry->inr[i * 9 + 6], symmetry->inr[i * 9 + 7], symmetry->inr[i * 9 + 8]);
    fprintf(file.out, "\n");
   }

  fclose(SYMM);

}

void read_XCBD_crystal_09(KPOINT_TRAN *knet, CRYSTAL *crystal, JOB_PARAM *job, FILES file)
//void read_XCBD_crystal_09(int nkunique, KPOINT_TRAN *knet, CRYSTAL *crystal, JOB_PARAM *job, FILES file)

{

  int i, j, latt, p, totalpoints;
  int ISfactors[3], kk[3];
  char line[151];
/*
  char tmp[] = "00", tmp1[] = "0", *tmp2, zz[4];

  sprintf(zz, "%d", job->taskid);
  if (job->taskid < 10) {
  strcat(tmp,zz);
  tmp2 = tmp;
 }
  if (job->taskid > 9 && job->taskid < 100) {
  strcat(tmp1,zz);
  tmp2 = tmp1;
 }
*/

  FILE *XCBD;
  char bb[13] = "XCBD.DAT.000";
  XCBD = fopen(bb, "r");
  //char aa[4], bb[13] = "XCBD.DAT.";
  //sprintf(aa, "%d", job->taskid);
  //XCBD = fopen(strcat(bb,tmp2), "r");
  //fprintf(file.out,"strcat %s\n",bb);
  //XCBD = fopen(strcat(bb, aa), "r");
  if (XCBD == NULL) { fprintf(file.out, "ERROR: Cannot open file 'XCBD.DAT'. in read_XCBD_crystal_09\n"); MPI_Finalize(); exit(1); }

  read_line(XCBD, line, 150); // read title

  read_line(XCBD, line, 150);
  sscanf(line, "%d %d %d %d", &ISfactors[0], &ISfactors[1], &ISfactors[2], &totalpoints);
     if (job->taskid == 0 && job->verbosity > 1) 
    fprintf(file.out, "%d %d %d %d\n", ISfactors[0], ISfactors[1], ISfactors[2], totalpoints);

  read_line(XCBD, line, 150);
     if (job->taskid == 0 && job->verbosity > 1) 
    fprintf(file.out,"%3d XCBD points\n",knet->unique);
    //fprintf(file.out,"%3d XCBD points\n",nkunique);
  //for (i = 0; i < nkunique; i++) {
  for (i = 0; i < knet->unique; i++) {
    read_line(XCBD, line, 150);
    sscanf(line, "%d %d %d %d %d", &j, &latt, &kk[0], &kk[1], &kk[2]);

  switch (crystal->type[0]) {
  case 'C':
    p = kk[0] * ISfactors[1] * ISfactors[2] + kk[1] * ISfactors[2] + kk[2]; 
    break;
  case 'S':
    p = kk[0] * ISfactors[1] + kk[1]; 
    break;
  case 'P':
    p = kk[0]; 
    break;
  case 'M':
    p = 0;
    break;
   }

  knet->ibz[i] = p;

  if (job->taskid == 0 && job->verbosity > 1) 
  fprintf(file.out,"%3d  %3d %3d %3d   %3d\n", i, kk[0], kk[1], kk[2], p);

   }
    
  read_line(XCBD, line, 150);
  read_line(XCBD, line, 150); // read Fermi energy
  sscanf(line, "%lf", &job->fermi_energy);
  if (job->taskid == 0 && job->verbosity > 1) 
  fprintf(file.out,"%lf Fermi Energy\n",job->fermi_energy);

  fclose(XCBD);

        if (job->taskid == 0 && job->verbosity > 1) {
        fprintf(file.out,"===========================================================================================================\n");
        fprintf(file.out,"|                                             READ XCBD FILE                                              |\n");
        fprintf(file.out,"===========================================================================================================\n");
       }

}

void write_vectors_write_values_rma3(int *isv, KPOINT_TRAN *knet, int *bands, ATOM *atoms, SYMMETRY *symmetry, CRYSTAL *crystal, JOB_PARAM *job, FILES file)
//void write_vectors_write_values_rma3(int *isv, int nkunique, KPOINT_TRAN *knet, int *bands, ATOM *atoms, SYMMETRY *symmetry, CRYSTAL *crystal, JOB_PARAM *job, FILES file)

{

  int nbands = bands[1] - bands[0] + 1;
  int nktot = isv[0] * isv[1] * isv[2];
  int kk[knet->unique][3];
  //int kk[nkunique][3];
  int k1[nktot][3];
  int *latt, *latt_full;

  double *eigval;
  MPI_File gh;

  char eigenvec_1[15] = "EIGENVEC.1.";
  char tmp[4] = "00", tmp1[4] = "0", *tmp2, zz[4];

  sprintf(zz, "%d", job->taskid);
  if (job->taskid < 10) {
  strcat(tmp,zz);
  tmp2 = tmp;
 }

  if (job->taskid > 9 && job->taskid < 100) {
  strcat(tmp1,zz);
  tmp2 = tmp1;
 }

  strcat(eigenvec_1, tmp2);

  char buf3[110];
  char zz1[10] = "/evalfile";

  strcpy(buf3,file.directory1);
  strcat(buf3,zz1);

  MPI_File_open(MPI_COMM_WORLD,buf3,MPI_MODE_RDWR | MPI_MODE_CREATE,MPI_INFO_NULL,&gh) ;

  //latt = (int *) malloc(nkunique * sizeof(int));
  latt = (int *) malloc(knet->unique * sizeof(int));
  if (latt == NULL) { fprintf(stderr, "ERROR: not enough memory for int latt! \n"); exit(1); }

  latt_full = (int *) malloc(nktot * sizeof(int));
  if (latt_full == NULL) { fprintf(stderr, "ERROR: not enough memory for int latt_full! \n"); exit(1); }

  //eigval = (double *) malloc(job->spin_dim * nkunique * nbands * sizeof(double));
  eigval = (double *) malloc(job->spin_dim * knet->unique * nbands * sizeof(double));
  if (eigval == NULL) { fprintf(stderr, "ERROR: not enough memory for double eigval! \n"); exit(1); }

  //read_evalues_crystal_09(nkunique, nktot, bands, latt, latt_full, kk, k1, &eigval[0], &eigval[nkunique * nbands], atoms, job, file);
  read_evalues_crystal_09(knet->unique, nktot, bands, latt, latt_full, kk, k1, &eigval[0], &eigval[knet->unique * nbands], atoms, job, file);

  MPI_File_seek(gh, 0, MPI_SEEK_SET) ;
  //MPI_File_write(gh, eigval, nkunique * nbands, MPI_DOUBLE, MPI_STATUS_IGNORE);
  //November2013 MPI_File_write(gh, eigval, knet->unique * nbands, MPI_DOUBLE, MPI_STATUS_IGNORE);
  MPI_File_write(gh, eigval, job->spin_dim * knet->unique * nbands, MPI_DOUBLE, MPI_STATUS_IGNORE);

  read_write_evectors_crystal_09(knet, knet->unique, k1, isv, bands, latt, eigenvec_1, atoms, job, file);
  //read_write_evectors_crystal_09(knet, nkunique, k1, isv, bands, latt, eigenvec_1, atoms, job, file);

  free(latt);
  free(latt_full);
  free(eigval);

  MPI_File_close(&gh) ;

  MPI_Barrier(MPI_COMM_WORLD);

}

void read_write_evectors_crystal_09a(KPOINT_TRAN *knet, int nkpt, int k1[][3], int *is, int *bands, int *latt, char *filename, ATOM *atoms, JOB_PARAM *job, FILES file)

{

  int i, j, k, ka, p, row, row1, s;
  int nbands = bands[1] - bands[0] + 1;
  int block_size, vector_size;
  int dim = atoms->number_of_sh_bfns_in_unit_cell * atoms->number_of_sh_bfns_in_unit_cell;
  int dim1 = atoms->number_of_sh_bfns_in_unit_cell;
  double *akv, *evector, *p_evector;
  char buf[110];
  char yy[10] = "/datafile";
  MPI_File fh;

  strcpy(buf,file.directory1);
  strcat(buf,yy);

  vector_size = nbands * atoms->number_of_sh_bfns_in_unit_cell;
  block_size = vector_size * sizeof(Complex);

  akv = (double *) malloc(2 * atoms->number_of_sh_bfns_in_unit_cell * sizeof(double));
  if (akv == NULL) { fprintf(stderr, "ERROR: not enough memory for double akv! \n"); exit(1); }

  evector = (double *) malloc(2 * vector_size * sizeof(double));
  if (evector == NULL) { fprintf(stderr, "ERROR: not enough memory for double evector! \n"); exit(1); }

  MPI_File_open(MPI_COMM_WORLD,buf,MPI_MODE_RDWR | MPI_MODE_CREATE,MPI_INFO_NULL,&fh) ;
  MPI_File_seek(fh, 0, MPI_SEEK_SET) ;

  ifstream io10(filename);
  if (!io10) { fprintf(stderr, "ERROR: Cannot open file %s \n",filename); exit(1); }
  io10.seekg(FORT_HEADER, ios::beg);

  for (s = 0; s < job->spin_dim; s++) {
    for (k = 0; k < nkpt; k++) {

    if (job->verbosity > 1)
      fprintf(file.out, "spin %3d k point %3d\n", s, k);

    p_evector = evector;

    switch (latt[k]) {

      case 1:

        row = (bands[0] - 1);
        io10.seekg(row * dim1 * sizeof(double), ios::cur);
        if (job->verbosity > 1)
          fprintf(file.out, "row bfns k p band1 band2 %d %3d %3d %3d %3d %3d %3d %10.4lf\n", \
          nbands, row, atoms->number_of_sh_bfns_in_unit_cell, k, p, bands[0], bands[1], akv[0]);
        for (i = 0; i < nbands; i++) {
          io10.read((char *) akv, dim1 * sizeof(double));
          for (j = 0; j < atoms->number_of_sh_bfns_in_unit_cell; j++) {
            *p_evector = akv[2 * j];
             if (job->verbosity > 1) fprintf(file.out, "band %3d orbital %3d evector Re %10.4lf \n", i, j, *p_evector);
             p_evector++;
            *p_evector = k_zero;
             p_evector++;
          }
        }
        row1 = dim1 - nbands - row;
        io10.seekg(row1 * dim1 * sizeof(double), ios::cur);

        break;

      case 0:

        row = (bands[0] - 1);
        io10.seekg(2 * row * dim1 * sizeof(double), ios::cur);
        if (job->verbosity > 1)
          fprintf(file.out, "roc bfns k p band1 band2 %d %3d %3d %3d %3d %3d %3d %10.4lf %10.4lf\n", \
          nbands, row, atoms->number_of_sh_bfns_in_unit_cell, k, p ,bands[0], bands[1], akv[0], akv[1]);
        for (i = 0; i < nbands; i++) {
          io10.read((char *) akv, 2 * dim1 * sizeof(double));
          for (j = 0; j < atoms->number_of_sh_bfns_in_unit_cell; j++) {
            *p_evector = akv[2 * j];
            if (job->verbosity > 1) fprintf(file.out, "band %3d orbital %3d evector Re %10.4lf  ", i, j, *p_evector);
             p_evector++;
            *p_evector = akv[2 * j + 1];
            if (job->verbosity > 1) fprintf(file.out, "Im %10.4lf\n", *p_evector);
             p_evector++;
          }
        }
        row1 = dim1 - nbands - row;
        io10.seekg(2 * row1 * dim1 * sizeof(double), ios::cur);

        break;

    } // end switch

    io10.seekg(FORT_TRAILER, ios::cur);
    MPI_File_write(fh, evector, 2 * vector_size, MPI_DOUBLE, MPI_STATUS_IGNORE);

   } // close loop over k
  } // close loop over s

  io10.close();
  MPI_File_close(&fh) ;

  free(akv);
  free(evector);

  return;

}

void read_write_evectors_crystal_09(KPOINT_TRAN *knet, int nkpt, int k1[][3], int *is, int *bands, int *latt, char *filename, ATOM *atoms, JOB_PARAM *job, FILES file)

{

  int i, j, k, ka, p, row, s;
  int nbands = bands[1] - bands[0] + 1;
  int block_size, vector_size;
  int dim = atoms->number_of_sh_bfns_in_unit_cell * atoms->number_of_sh_bfns_in_unit_cell;
  double *akv, *evector, *p_evector;
  char buf[110];
  char yy[10] = "/datafile";
  MPI_File fh;

  strcpy(buf,file.directory1);
  strcat(buf,yy);

  vector_size = nbands * atoms->number_of_sh_bfns_in_unit_cell;
  block_size = vector_size * sizeof(Complex);

  akv = (double *) malloc(2 * atoms->number_of_sh_bfns_in_unit_cell * atoms->number_of_sh_bfns_in_unit_cell * sizeof(double));
  if (akv == NULL) { fprintf(stderr, "ERROR: not enough memory for double akv! \n"); exit(1); }

  evector = (double *) malloc(2 * vector_size * sizeof(double));
  if (evector == NULL) { fprintf(stderr, "ERROR: not enough memory for double evector! \n"); exit(1); }

  MPI_File_open(MPI_COMM_WORLD,buf,MPI_MODE_RDWR | MPI_MODE_CREATE,MPI_INFO_NULL,&fh) ;
  MPI_File_seek(fh, 0, MPI_SEEK_SET) ;

  ifstream io10(filename);
  if (!io10) { fprintf(stderr, "ERROR: Cannot open file %s \n",filename); exit(1); }
  io10.seekg(FORT_HEADER, ios::beg);

  for (s = 0; s < job->spin_dim; s++) {
    for (k = 0; k < nkpt; k++) {

    if (job->verbosity > 1)
      fprintf(file.out, "spin %3d k point %3d\n", s, k);

    p_evector = evector;

    switch (latt[k]) {

      case 1:

        io10.read((char *) akv, dim * sizeof(double));
        row = (bands[0] - 1) * atoms->number_of_sh_bfns_in_unit_cell;
         if (job->verbosity > 1)
          fprintf(file.out, "row bfns k p band1 band2 %d %3d %3d %3d %3d %3d %3d %10.4lf\n", \
          nbands, row, atoms->number_of_sh_bfns_in_unit_cell, k, p, bands[0],
              bands[1], akv[row]);
        for (i = 0; i < nbands; i++) {
          for (j = 0; j < atoms->number_of_sh_bfns_in_unit_cell; j++) {
            *p_evector = akv[row];
             if (job->verbosity > 1)
              fprintf(file.out, "band %3d orbital %3d evector Re %10.4lf \n", i, j, *p_evector);
              //if (i > 240 && i < 516 && k == 0 && fabs(*p_evector) > 0.45) fprintf(file.out,"%3d %3d %10.4lf\n",i,j,*p_evector);
              //fprintf(file.out, "band %3d orbital %3d evector Re %10.4lf \n", i, j, evector[k].akfull[i][j].real());
              p_evector++;
              *p_evector = k_zero;
              p_evector++;
              //evector[k].akfull[i][j] = Complex(akv[row], k_zero);
              row++;
          }
        }
        break;

      case 0:

       io10.read((char *) akv, 2 * dim * sizeof(double));
        row = 2 * (bands[0] - 1) * atoms->number_of_sh_bfns_in_unit_cell;
         if (job->verbosity > 1)
          fprintf(file.out, "roc bfns k p band1 band2 %d %3d %3d %3d %3d %3d %3d %10.4lf %10.4lf\n", \
          nbands, row, atoms->number_of_sh_bfns_in_unit_cell, k, p,
          bands[0], bands[1], akv[row], akv[row + 1]);
        for (i = 0; i < nbands; i++) {
          for (j = 0; j < atoms->number_of_sh_bfns_in_unit_cell; j++) {
            *p_evector = akv[row];
            if (job->verbosity > 1)
              fprintf(file.out, "band %3d orbital %3d evector Re %10.4lf  ", i, j, *p_evector);
             p_evector++;
            //evector[k].akfull[i][j] = Complex(akv[row], akv[row + 1]);
            *p_evector = akv[row + 1];
            if (job->verbosity > 1)
              fprintf(file.out, "Im %10.4lf\n", *p_evector);
              //fprintf(file.out, "band %3d orbital %3d evector Re %10.4lf \n", i, j, evector[k].akfull[i][j].real());
             p_evector++;
            row += 2;
          }
        }

    } // end switch

    io10.seekg(FORT_TRAILER, ios::cur);
    MPI_File_write(fh, evector, 2 * vector_size, MPI_DOUBLE, MPI_STATUS_IGNORE);

   } // close loop over k
  } // close loop over s

  io10.close();
  MPI_File_close(&fh) ;

  free(akv);
  free(evector);

  return;

}

void read_evalues_crystal_09(int nkpt, int nktot, int *bands, int *latt, int *latt_full, int kk[][3], int k1[][3], double *eig1, double *eig2, ATOM *atoms, JOB_PARAM *job, FILES file)

{

  int i, j;
  int totalpoints, ISfactors[3];
  int result;
  double *p_eig1, *p_eig2, temp;
  char line[151];
  char tmp[] = "00", tmp1[] = "0", *tmp2, zz[4];

  sprintf(zz, "%d", job->taskid);
  if (job->taskid < 10) {
  strcat(tmp,zz);
  tmp2 = tmp;
 }
  if (job->taskid > 9 && job->taskid < 100) {
  strcat(tmp1,zz);
  tmp2 = tmp1;
 }

  FILE *XCBD;
  char aa[4], bb[13] = "XCBD.DAT.";
  sprintf(aa, "%d", job->taskid);
  XCBD = fopen(strcat(bb,tmp2), "r");
  //fprintf(file.out,"strcat %s\n",bb);
  //XCBD = fopen(strcat(bb, aa), "r");
  if (XCBD == NULL) { fprintf(stderr, "ERROR: Cannot open file 'XCBD.DAT'. \n"); exit(1); }

  p_eig1 = eig1;
  p_eig2 = eig2;

  read_line(XCBD, line, 150); // read title

  read_line(XCBD, line, 150);
  sscanf(line, "%d %d %d %d", &ISfactors[0], &ISfactors[1], &ISfactors[2], &totalpoints);
    if (job->verbosity > 1)
    fprintf(file.out, "%d %d %d %d\n", ISfactors[0], ISfactors[1], ISfactors[2], totalpoints);

  read_line(XCBD, line, 150);
  for (i = 0; i < nkpt; i++) {
    read_line(XCBD, line, 150);
    sscanf(line, "%d %d %d %d %d", &j, &latt[i], &kk[i][0], &kk[i][1], &kk[i][2]);
     if (job->verbosity > 1)
      fprintf(file.out, "Latt = %d\n", latt[i]);
  }

  read_line(XCBD, line, 150);
  read_line(XCBD, line, 150);
  sscanf(line, "%lf", &job->fermi_energy);
    if (job->verbosity > 1) {
    fprintf(file.out, "Fermi energy = %lf\n", job->fermi_energy);
    fprintf(file.out, "Range of bands = %d %d\n", bands[0],bands[1]);
   }

  switch (job->spin_polarisation) {
    case TRUE: // spin polarised system
      // spin up
      for (i = 0; i < nkpt; i++) { // kpoints loop
        read_line(XCBD, line, 150);
        read_line(XCBD, line, 150);
        for (j = 1; j <= atoms->number_of_sh_bfns_in_unit_cell; j++) {
          result = fscanf(XCBD, "%le", &temp);
          if (j >= bands[0] && j <= bands[1]) {
            *p_eig1 = temp;
              if (job->verbosity > 1)
              fprintf(file.out, "KPOINT %d BAND UP %d EIGENVALUE %lf\n", i, j, *p_eig1);
            p_eig1++;
          }
        }
        read_line(XCBD, line, 150);
      } // end k-points loop
      // spin down
      for (i = 0; i < nkpt; i++) { // kpoints loop
        read_line(XCBD, line, 150);
        read_line(XCBD, line, 150);
        for (j = 1; j <= atoms->number_of_sh_bfns_in_unit_cell; j++) {
          result = fscanf(XCBD, "%le", &temp);
          if (j >= bands[0] && j <= bands[1]) {
            *p_eig2 = temp;
             if (job->verbosity > 1)
              fprintf(file.out, "KPOINT %d BAND DOWN %d EIGENVALUE %lf\n", i, j, *p_eig2);
            p_eig2++;
          }
        }
        read_line(XCBD, line, 150);
      } // end k-points loop
      break; // End reading eigenvalues for spin polarised system

    case FALSE: // closed shell system
      for (i = 0; i < nkpt; i++) { // kpoints loop
        read_line(XCBD, line, 150);
        read_line(XCBD, line, 150);
        //for (j = 1; j <= ndf; j++) {
        for (j = 1; j <= atoms->number_of_sh_bfns_in_unit_cell; j++) {
          result = fscanf(XCBD, "%le", &temp);
          if (j >= bands[0] && j <= bands[1]) {
            *p_eig1 = temp;
             if (job->verbosity > 1)
              fprintf(file.out, "KPOINT %d BAND %d EIGENVALUE %lf\n", i, j, *p_eig1);
            p_eig1++;
          }
        }
        read_line(XCBD, line, 150);
      } // end k-points loop
      // end reading  eigenvalues for closed shell system

  } // end switch

    read_line(XCBD, line, 150);
  for(i=0;i<nktot;i++) {
    read_line(XCBD, line, 150);
    sscanf(line, "%d %d %d %d %d", &j, &latt_full[i], &k1[i][0], &k1[i][1], &k1[i][2]);
   } 

  fclose(XCBD);
  return;

}

/*
void get_vectors_values(int *isv, int *nk, int *bands, VECTOR_KNET *knet, double *eigenvectors, double *eigenvalues, ATOM *atoms, JOB_PARAM *job, FILES file)

{

  int i, j, k, nkpt = nk[1] - nk[0], nbands = bands[1] - bands[0] + 1, *latt;
  int vector_size = nbands * nkpt * atoms->number_of_sh_bfns_in_unit_cell;
  int size, rank;
  double *akv;

  MPI_Comm_size(MPI_COMM_WORLD, &size);
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);

  char xx[4], eigenvec_1[] = "EIGENVEC.1.", eigenvec_2[] = "EIGENVEC.2.";
  sprintf(xx, "%d", rank);
  strcat(eigenvec_1, xx);
  strcat(eigenvec_2, xx);

  akv = (double *) malloc(2 * atoms->number_of_sh_bfns_in_unit_cell * atoms->number_of_sh_bfns_in_unit_cell * sizeof(double));
  if (akv == NULL) { fprintf(stderr, "ERROR: not enough memory for double akv! \n"); exit(1); }

  latt = (int *) malloc(nkpt * sizeof(int));
  if (latt == NULL) { fprintf(stderr, "ERROR: not enough memory for int latt! \n"); exit(1); }

  FILE *band_gen;
  char yy[] = "band.gen.";
  band_gen = fopen(strcat(yy, xx), "w");
  if (band_gen == NULL) { fprintf(stderr, "ERROR: Cannot open file 'band.gen'. \n"); exit(1); }

  fprintf(band_gen, "XCBD\n");
  fprintf(band_gen, "1  2  1%3d\n", rank);
  fprintf(band_gen, "%5d %4d %4d\n", isv[0], isv[1], isv[2]);
  fprintf(band_gen, "%5d\n", nkpt);
  for (i = nk[0]; i < nk[1]; i++)
  fprintf(band_gen, "%4d %4d %4d\n", knet[i].oblique.comp1, knet[i].oblique.comp2, knet[i].oblique.comp3);
  fprintf(band_gen, "0\n");
  fprintf(band_gen, "END\n");
  fprintf(band_gen, "END\n");
  fflush(band_gen);

  run_properties(3, 1, 0, job, file);
  read_eivalues(nkpt, bands, latt, eigenvalues, atoms, job, file);
  read_evectors(nkpt, bands, latt, akv, eigenvectors, eigenvec_1, atoms, job, file);
  ////rearrange_evectors1(nkpt, nbands, eigenvectors);
  //rearrange_evectors(nkpt,eigenvectors) ;
  if (job->spin_polarisation == 1)
    read_evectors(nkpt, bands, latt, akv, &eigenvectors[vector_size], eigenvec_2, atoms, job, file);
  //if (job->spin_polarisation == 1)
    ////rearrange_evectors1(nkpt, nbands, &eigenvectors[vector_size]);
  //if (spin_polarisation==1) rearrange_evectors(nkpt,&eigenvectors[vector_size]) ;

  free(akv);
  free(latt);

}

void get_vectors_get_values(int *isv, int *nk, int *bands, VECTOR_KNET *knet, ComplexMatrix *eigenvectors, double *eigenvalues, ATOM *atoms, JOB_PARAM *job, FILES file)

{

  int i, j, k, nkpt = nk[1] - nk[0], nbands = bands[1] - bands[0] + 1, *latt;
  int vector_size = nbands * nkpt * atoms->number_of_sh_bfns_in_unit_cell;
  int size, rank;
  double *akv;

  MPI_Comm_size(MPI_COMM_WORLD, &size);
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);

  char xx[4], eigenvec_1[] = "EIGENVEC.1.", eigenvec_2[] = "EIGENVEC.2.";
  sprintf(xx, "%d", rank);
  strcat(eigenvec_1, xx);
  strcat(eigenvec_2, xx);

  akv = (double *) malloc(2 * atoms->number_of_sh_bfns_in_unit_cell * atoms->number_of_sh_bfns_in_unit_cell * sizeof(double));
  if (akv == NULL) { fprintf(stderr, "ERROR: not enough memory for double akv! \n"); exit(1); }

  latt = (int *) malloc(nkpt * sizeof(int));
  if (latt == NULL) { fprintf(stderr, "ERROR: not enough memory for int latt! \n"); exit(1); }

  FILE *band_gen;
  char yy[] = "band.gen.";
  band_gen = fopen(strcat(yy, xx), "w");
  if (band_gen == NULL) { fprintf(stderr, "ERROR: Cannot open file 'band.gen'. \n"); exit(1); }

  fprintf(band_gen, "XCBD\n");
  fprintf(band_gen, "1  2  1%3d\n", rank);
  fprintf(band_gen, "%5d %4d %4d\n", isv[0], isv[1], isv[2]);
  fprintf(band_gen, "%5d\n", nkpt);
  for (i = nk[0]; i < nk[1]; i++)
  fprintf(band_gen, "%4d %4d %4d\n", knet[i].oblique.comp1, knet[i].oblique.comp2, knet[i].oblique.comp3);
  fprintf(band_gen, "0\n");
  fprintf(band_gen, "END\n");
  fprintf(band_gen, "END\n");
  fflush(band_gen);

  run_properties(3, 1, 0, job, file);
  read_eivalues(nkpt, bands, latt, eigenvalues, atoms, job, file);
  read_vectors(nkpt, bands, latt, akv, eigenvectors, eigenvec_1, atoms, job, file);
  if (job->spin_polarisation == 1)
  read_vectors(nkpt, bands, latt, akv, &eigenvectors[vector_size], eigenvec_2, atoms, job, file);

  free(akv);
  free(latt);

}

void get_values(int *isv, int *nk, int *bands, VECTOR_KNET *knet, double *eigenvalues, ATOM *atoms, JOB_PARAM *job, FILES file)

{

  int i, j, k, nkpt = nk[1] - nk[0], nbands = bands[1] - bands[0] + 1, *latt ;
  char xx[4], eigenvec_1[] = "EIGENVEC.1.", eigenvec_2[] = "EIGENVEC.2.";
  sprintf(xx, "%d", job->taskid);
  strcat(eigenvec_1, xx);
  strcat(eigenvec_2, xx);

  latt = (int *) malloc(nkpt * sizeof(int));
  if (latt == NULL) { fprintf(stderr, "ERROR: not enough memory for int latt! \n"); exit(1); }

  FILE *band_gen;
  char yy[] = "band.gen.";
  band_gen = fopen(strcat(yy, xx), "w");
  if (band_gen == NULL) { fprintf(stderr, "ERROR: Cannot open file 'band.gen'. \n"); exit(1); }

  fprintf(band_gen, "XCBD\n");
  fprintf(band_gen, "1  2  1%3d\n", job->taskid);
  fprintf(band_gen, "%5d %4d %4d\n", isv[0], isv[1], isv[2]);
  fprintf(band_gen, "%5d\n", nkpt);
  for (i = nk[0]; i < nk[1]; i++)
  fprintf(band_gen, "%4d %4d %4d\n", knet[i].oblique.comp1, knet[i].oblique.comp2, knet[i].oblique.comp3);
  fprintf(band_gen, "0\n");
  fprintf(band_gen, "END\n");
  fprintf(band_gen, "END\n");
  fflush(band_gen);

  run_properties(3, 1, 0, job, file);
  read_eivalues(nkpt, bands, latt, eigenvalues, atoms, job, file);

  free(latt);

}

void read_evectors(int nkpt, int *bands, int *latt, double *akv, double *evector, char *filename, ATOM *atoms, JOB_PARAM *job, FILES file)

{

  int i, j, k, ka, row;
  int nbands = bands[1] - bands[0] + 1;
  int dim = atoms->number_of_sh_bfns_in_unit_cell * atoms->number_of_sh_bfns_in_unit_cell;
  double *p_evector;

  ifstream io10(filename);
  if (!io10) { fprintf(stderr, "ERROR: Cannot open file %s \n",filename); exit(1); }
  io10.seekg(FORT_HEADER, ios::beg);

  p_evector = evector;

  for (k = 0; k < nkpt; k++) {

    if (job->verbosity > 1)
      fprintf(file.out, "k point %3d\n", k);

    switch (latt[k]) {

      case 1:

        io10.read((char *) akv, dim * sizeof(double));
        row = (bands[0] - 1) * atoms->number_of_sh_bfns_in_unit_cell;
         if (job->verbosity > 1)
          fprintf(file.out, "row bfns k band1 band2 %d %3d %3d %3d %3d %3d %10.4lf\n", \
          nbands, row, atoms->number_of_sh_bfns_in_unit_cell, k, bands[0],
              bands[1], akv[row]);
        for (i = 0; i < nbands; i++) {
          for (j = 0; j < atoms->number_of_sh_bfns_in_unit_cell; j++) {
            *p_evector = akv[row];
             if (job->verbosity > 1)
              fprintf(file.out, "band %3d orbital %3d evector Re %10.4lf \n", i, j, *p_evector);
              //fprintf(file.out, "band %3d orbital %3d evector Re %10.4lf \n", i, j, evector[k].akfull[i][j].real());
              p_evector++;
              *p_evector = k_zero;
              p_evector++;
              //evector[k].akfull[i][j] = Complex(akv[row], k_zero);
              row++;
          }
        }
        break;

      case 0:

       io10.read((char *) akv, 2 * dim * sizeof(double));
        row = 2 * (bands[0] - 1) * atoms->number_of_sh_bfns_in_unit_cell;
         if (job->verbosity > 1)
          fprintf(file.out, "roc bfns k band1 band2 %d %3d %3d %3d %3d %3d %10.4lf %10.4lf\n", \
          nbands, row, atoms->number_of_sh_bfns_in_unit_cell, k,
          bands[0], bands[1], akv[row], akv[row + 1]);
        for (i = 0; i < nbands; i++) {
          for (j = 0; j < atoms->number_of_sh_bfns_in_unit_cell; j++) {
            *p_evector = akv[row];
            if (job->verbosity > 1)
              fprintf(file.out, "band %3d orbital %3d evector Re %10.4lf  ", i, j, *p_evector);
             p_evector++;
            //evector[k].akfull[i][j] = Complex(akv[row], akv[row + 1]);
            *p_evector = akv[row + 1];
            if (job->verbosity > 1)
              fprintf(file.out, "Im %10.4lf\n", *p_evector);
              //fprintf(file.out, "band %3d orbital %3d evector Re %10.4lf \n", i, j, evector[k].akfull[i][j].real());
             p_evector++;
            row += 2;
          }
        }

    } // end switch

    io10.seekg(FORT_TRAILER, ios::cur);

  } // close loop over k

  io10.close();

  return;

}

void read_evectors_crystal_09(KPOINT_TRAN *knet, int nkpt, int k1[][3], int *is, int *bands, int *latt, double *akv, double *evector, char *filename, ATOM *atoms, JOB_PARAM *job, FILES file)

{

  int i, j, k, ka, p, row, s;
  int nbands = bands[1] - bands[0] + 1;
  int dim = atoms->number_of_sh_bfns_in_unit_cell * atoms->number_of_sh_bfns_in_unit_cell;
  double *p_evector;

  ifstream io10(filename);
  if (!io10) { fprintf(stderr, "ERROR: Cannot open file %s \n",filename); exit(1); }
  io10.seekg(FORT_HEADER, ios::beg);

  //CHECK p_evector = evector;
  p_evector = evector;

  for (s = 0; s < job->spin_dim; s++) {
    for (k = 0; k < nkpt; k++) {

    if (job->verbosity > 1)
      fprintf(file.out, "spin %3d k point %3d\n", s, k);

    //p = k1[k][0] * is[1] * is[2] + k1[k][1] * is[2] + k1[k][2]; 
    //if (knet->trs[p] == 1)
      //continue; // This vector will be generated elsewhere by time reversal symmetry
    // CHECK p_evector = evector + 2 * p * nbands * atoms->number_of_sh_bfns_in_unit_cell;

    switch (latt[k]) {

      case 1:

        io10.read((char *) akv, dim * sizeof(double));
        row = (bands[0] - 1) * atoms->number_of_sh_bfns_in_unit_cell;
         if (job->verbosity > 1)
          fprintf(file.out, "row bfns k p band1 band2 %d %3d %3d %3d %3d %3d %3d %10.4lf\n", \
          nbands, row, atoms->number_of_sh_bfns_in_unit_cell, k, p, bands[0],
              bands[1], akv[row]);
        for (i = 0; i < nbands; i++) {
          for (j = 0; j < atoms->number_of_sh_bfns_in_unit_cell; j++) {
            *p_evector = akv[row];
             if (job->verbosity > 1)
              fprintf(file.out, "band %3d orbital %3d evector Re %10.4lf \n", i, j, *p_evector);
              //fprintf(file.out, "band %3d orbital %3d evector Re %10.4lf \n", i, j, evector[k].akfull[i][j].real());
              p_evector++;
              *p_evector = k_zero;
              p_evector++;
              //evector[k].akfull[i][j] = Complex(akv[row], k_zero);
              row++;
          }
        }
        break;

      case 0:

       io10.read((char *) akv, 2 * dim * sizeof(double));
        row = 2 * (bands[0] - 1) * atoms->number_of_sh_bfns_in_unit_cell;
         if (job->verbosity > 1)
          fprintf(file.out, "roc bfns k p band1 band2 %d %3d %3d %3d %3d %3d %3d %10.4lf %10.4lf\n", \
          nbands, row, atoms->number_of_sh_bfns_in_unit_cell, k, p,
          bands[0], bands[1], akv[row], akv[row + 1]);
        for (i = 0; i < nbands; i++) {
          for (j = 0; j < atoms->number_of_sh_bfns_in_unit_cell; j++) {
            *p_evector = akv[row];
            if (job->verbosity > 1)
              fprintf(file.out, "band %3d orbital %3d evector Re %10.4lf  ", i, j, *p_evector);
             p_evector++;
            //evector[k].akfull[i][j] = Complex(akv[row], akv[row + 1]);
            *p_evector = akv[row + 1];
            if (job->verbosity > 1)
              fprintf(file.out, "Im %10.4lf\n", *p_evector);
              //fprintf(file.out, "band %3d orbital %3d evector Re %10.4lf \n", i, j, evector[k].akfull[i][j].real());
             p_evector++;
            row += 2;
          }
        }

    } // end switch

    io10.seekg(FORT_TRAILER, ios::cur);

   } // close loop over k
  } // close loop over s

  io10.close();

  return;

}

void read_vectors(int nkpt, int *bands, int *latt, double *akv, ComplexMatrix *evector, char *filename, ATOM *atoms, JOB_PARAM *job, FILES file)

{

  int i, j, k, ka, row;
  int nbands = bands[1] - bands[0] + 1;
  int dim = atoms->number_of_sh_bfns_in_unit_cell * atoms->number_of_sh_bfns_in_unit_cell;

  ifstream io10(filename);
  if (!io10) { fprintf(stderr, "ERROR: Cannot open file 'fort.10' \n"); exit(1); }
  io10.seekg(FORT_HEADER, ios::beg);

  for (k = 0; k < nkpt; k++) {

    if (job->verbosity > 1)
      fprintf(file.out, "k point %3d\n", k);

    switch (latt[k]) {

      case 1:

        io10.read((char *) akv, dim * sizeof(double));
        row = (bands[0] - 1) * atoms->number_of_sh_bfns_in_unit_cell;
         if (job->verbosity > 1)
          fprintf(file.out, "row bfns k band1 band2 %d %3d %3d %3d %3d %3d %10.4lf\n", \
          nbands, row, atoms->number_of_sh_bfns_in_unit_cell, k, bands[0],
              bands[1], akv[row]);
        for (i = 0; i < nbands; i++) {
          for (j = 0; j < atoms->number_of_sh_bfns_in_unit_cell; j++) {
             evector->a[i][j] = Complex(akv[row],k_zero);
             if (job->verbosity > 1)
              fprintf(file.out, "band %3d orbital %3d evector %10.4lf %10.4lf\n", i, j,
              evector->a[i][j].real(),evector->a[i][j].imag());
              row++;
             }
            }
           break;

      case 0:

       io10.read((char *) akv, 2 * dim * sizeof(double));
        row = 2 * (bands[0] - 1) * atoms->number_of_sh_bfns_in_unit_cell;
         if (job->verbosity > 1)
          fprintf(file.out, "roc bfns k band1 band2 %d %3d %3d %3d %3d %3d %10.4lf %10.4lf\n", \
          nbands, row, atoms->number_of_sh_bfns_in_unit_cell, k,
          bands[0], bands[1], akv[row], akv[row + 1]);
        for (i = 0; i < nbands; i++) {
          for (j = 0; j < atoms->number_of_sh_bfns_in_unit_cell; j++) {
            evector->a[i][j] = Complex(akv[row],akv[row + 1]);
            if (job->verbosity > 1)
              fprintf(file.out, "band %3d orbital %3d evector %10.4lf %10.4lf", i, j,
              evector->a[i][j].real(),evector->a[i][j].imag());
            if (job->verbosity > 1)
              fprintf(file.out, "Im %10.4lf %10.4lf\n", evector->a[i][j].real(),evector->a[i][j].imag());
            row += 2;
           }
          }

       } // end switch

    io10.seekg(FORT_TRAILER, ios::cur);

  } // close loop over k

  io10.close();

  return;

}

void read_evalues(int nkpt, int *bands, int *latt, int kk[][3], double *eig1, double *eig2, ATOM *atoms, JOB_PARAM *job, FILES file)

{

  int i, j;
  //int i, j, k[3];
  int totalpoints, ISfactors[3];
  double *p_eig1, *p_eig2, temp;
  char line[151];
  FILE *band_out;
  char xx[4], yy[10] = "band.out." ;
  char tmp[] = "00", tmp1[] = "0", *tmp2, zz[4];

  sprintf(zz, "%d", job->taskid);
  if (job->taskid < 10) {
  strcat(tmp,zz);
  tmp2 = tmp;
 }
  if (job->taskid > 9 && job->taskid < 100) {
  strcat(tmp1,zz);
  tmp2 = tmp1;
 }


  sprintf(xx, "%d", job->taskid);
  band_out = fopen(strcat(yy,tmp2), "r");
  //band_out = fopen(strcat(yy, xx), "r");
  if (band_out == NULL) {  fprintf(stderr, "ERROR: Cannot open file 'band.out'. \n"); exit(1); }
  if (search_file(band_out, "ERROR") == TRUE) { fprintf(file.err,"ERROR in file band.out\n"); }
  fclose(band_out);

  FILE *XCBD;
  char aa[4], bb[13] = "XCBD.DAT.";
  //char aa[4], bb[10] = "XCBD.DAT.";
  sprintf(aa, "%d", job->taskid);
  XCBD = fopen(strcat(bb,tmp2), "r");
  //fprintf(file.out,"strcat %s\n",bb);
  //XCBD = fopen(strcat(bb, aa), "r");
  if (XCBD == NULL) { fprintf(stderr, "ERROR: Cannot open file 'XCBD.DAT'. \n"); exit(1); }

  p_eig1 = eig1;
  p_eig2 = eig2;

  read_line(XCBD, line, 150); // read title

  read_line(XCBD, line, 150);
  sscanf(line, "%d %d %d %d", &ISfactors[0], &ISfactors[1], &ISfactors[2], &totalpoints);
    if (job->verbosity > 1)
    fprintf(file.out, "%d %d %d %d\n", ISfactors[0], ISfactors[1], ISfactors[2], totalpoints);

  read_line(XCBD, line, 150);
  for (i = 0; i < nkpt; i++) {
    read_line(XCBD, line, 150);
    sscanf(line, "%d %d %d %d %d", &j, &latt[i], &kk[i][0], &kk[i][1], &kk[i][2]);
//    sscanf(line, "%d %d %d %d %d", &j, &latt[i], &k[0], &k[1], &k[3]);
     if (job->verbosity > 1)
      fprintf(file.out, "Latt = %d\n", latt[i]);
  }

  read_line(XCBD, line, 150);
  read_line(XCBD, line, 150);
  sscanf(line, "%lf", &job->fermi_energy);
    if (job->verbosity > 1) {
    fprintf(file.out, "Fermi energy = %lf\n", job->fermi_energy);
    fprintf(file.out, "Range of bands = %d %d\n", bands[0],bands[1]);
   }

  switch (job->spin_polarisation) {
    case TRUE: // spin polarised system
      // spin up
      for (i = 0; i < nkpt; i++) { // kpoints loop
        read_line(XCBD, line, 150);
        read_line(XCBD, line, 150);
        for (j = 1; j <= atoms->number_of_sh_bfns_in_unit_cell; j++) {
          fscanf(XCBD, "%le", &temp);
          if (j >= bands[0] && j <= bands[1]) {
            *p_eig1 = temp;
              if (job->verbosity > 1)
              fprintf(file.out, "KPOINT %d BAND UP %d EIGENVALUE %lf\n", i, j, *p_eig1);
            p_eig1++;
          }
        }
        read_line(XCBD, line, 150);
      } // end k-points loop
      // spin down
      for (i = 0; i < nkpt; i++) { // kpoints loop
        read_line(XCBD, line, 150);
        read_line(XCBD, line, 150);
        for (j = 1; j <= atoms->number_of_sh_bfns_in_unit_cell; j++) {
          fscanf(XCBD, "%le", &temp);
          if (j >= bands[0] && j <= bands[1]) {
            *p_eig2 = temp;
             if (job->verbosity > 1)
              fprintf(file.out, "KPOINT %d BAND DOWN %d EIGENVALUE %lf\n", i, j, *p_eig2);
            p_eig2++;
          }
        }
        read_line(XCBD, line, 150);
      } // end k-points loop
      break; // End reading eigenvalues for spin polarised system

    case FALSE: // closed shell system
      for (i = 0; i < nkpt; i++) { // kpoints loop
        read_line(XCBD, line, 150);
        read_line(XCBD, line, 150);
        //for (j = 1; j <= ndf; j++) {
        for (j = 1; j <= atoms->number_of_sh_bfns_in_unit_cell; j++) {
          fscanf(XCBD, "%le", &temp);
          if (j >= bands[0] && j <= bands[1]) {
            *p_eig1 = temp;
             if (job->verbosity > 1)
              fprintf(file.out, "KPOINT %d BAND %d EIGENVALUE %lf\n", i, j, *p_eig1);
            p_eig1++;
          }
        }
        read_line(XCBD, line, 150);
      } // end k-points loop
      // end reading  eigenvalues for closed shell system

  } // end switch

  fclose(XCBD);
  return;

}

void read_eivalues(int nkpt, int *bands, int *latt, double *eigenvalues, ATOM *atoms, JOB_PARAM *job, FILES file)

{

  int i, j, k[3];
  int totalpoints, ISfactors[3];
  double *p_eigenvalues, temp;
  char line[151];
  FILE *band_out;
  char xx[4], yy[10] = "band.out.";
  sprintf(xx, "%d", job->taskid);
  band_out = fopen(strcat(yy, xx), "r");
  if (band_out == NULL) {  fprintf(stderr, "ERROR: Cannot open file 'band.out'. \n"); exit(1); }
  if (search_file(band_out, "ERROR") == TRUE) { fprintf(file.err,"ERROR in file band.out\n"); }
  fclose(band_out);

  FILE *XCBD;
  char aa[4], bb[10] = "XCBD.DAT.";
  sprintf(aa, "%d", job->taskid);
  XCBD = fopen(strcat(bb, aa), "r");
  if (XCBD == NULL) { fprintf(stderr, "ERROR: Cannot open file 'XCBD.DAT'. \n"); exit(1); }

  p_eigenvalues = eigenvalues;

  read_line(XCBD, line, 150); // read title

  read_line(XCBD, line, 150);
  sscanf(line, "%d %d %d %d", &ISfactors[0], &ISfactors[1], &ISfactors[2], &totalpoints);
    if (job->verbosity == 1)
    fprintf(file.out, "%d %d %d %d\n", ISfactors[0], ISfactors[1], ISfactors[2], totalpoints);

  read_line(XCBD, line, 150);
  for (i = 0; i < nkpt; i++) {
    read_line(XCBD, line, 150);
    sscanf(line, "%d %d %d %d %d", &j, &latt[i], &k[0], &k[1], &k[2]);
//    sscanf(line, "%d %d %d %d %d", &j, &latt[i], &k[0], &k[1], &k[3]);
     if (job->verbosity > 1)
      fprintf(file.out, "Latt = %d\n", latt[i]);
  }

  read_line(XCBD, line, 150);
  read_line(XCBD, line, 150);
  sscanf(line, "%lf", &job->fermi_energy);
    if (job->verbosity == 1) {
    fprintf(file.out, "Fermi energy = %lf\n", job->fermi_energy);
    fprintf(file.out, "Range of bands = %d %d\n", bands[0],bands[1]);
   }

  switch (job->spin_polarisation) {
    case TRUE: // spin polarised system
      // spin up
      for (i = 0; i < nkpt; i++) { // kpoints loop
        read_line(XCBD, line, 150);
        read_line(XCBD, line, 150);
        for (j = 1; j <= atoms->number_of_sh_bfns_in_unit_cell; j++) {
          fscanf(XCBD, "%le", &temp);
          if (j >= bands[0] && j <= bands[1]) {
            *p_eigenvalues = temp;
              if (job->verbosity == 1)
              fprintf(file.out, "KPOINT %d BAND UP %d EIGENVALUE %lf\n", i, j, *p_eigenvalues);
            p_eigenvalues++;
          }
        }
        read_line(XCBD, line, 150);
      } // end k-points loop
      // spin down
      for (i = 0; i < nkpt; i++) { // kpoints loop
        read_line(XCBD, line, 150);
        read_line(XCBD, line, 150);
        for (j = 1; j <= atoms->number_of_sh_bfns_in_unit_cell; j++) {
          fscanf(XCBD, "%le", &temp);
          if (j >= bands[0] && j <= bands[1]) {
            *p_eigenvalues = temp;
             if (job->verbosity == 1)
              fprintf(file.out, "KPOINT %d BAND DOWN %d EIGENVALUE %lf\n", i, j, *p_eigenvalues);
            p_eigenvalues++;
          }
        }
        read_line(XCBD, line, 150);
      } // end k-points loop
      break; // End reading eigenvalues for spin polarised system

    case FALSE: // closed shell system
      for (i = 0; i < nkpt; i++) { // kpoints loop
        read_line(XCBD, line, 150);
        read_line(XCBD, line, 150);
        //for (j = 1; j <= ndf; j++) {
        for (j = 1; j <= atoms->number_of_sh_bfns_in_unit_cell; j++) {
          fscanf(XCBD, "%le", &temp);
          if (j >= bands[0] && j <= bands[1]) {
            *p_eigenvalues = temp;
             if (job->verbosity > 1)
              fprintf(file.out, "KPOINT %d BAND %d EIGENVALUE %lf\n", i, j, *p_eigenvalues);
            p_eigenvalues++;
          }
        }
        read_line(XCBD, line, 150);
      } // end k-points loop
      // end reading  eigenvalues for closed shell system

  } // end switch

  fclose(XCBD);
  return;

}

void run_properties(char crystal, int kk, int test, JOB_PARAM *job, FILES file)

{

  int size, rank;

  MPI_Comm_size(MPI_COMM_WORLD, &size);
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);

  char tmp[4] = "00", tmp1[4] = "0", *tmp2;
  char xx[60] = "./properties < band.gen.", yy[4], zz[16] = " > band.out.";

  sprintf(yy, "%d", job->taskid);
  if (job->taskid < 10) {
  strcat(tmp,yy);
  tmp2 = tmp;
 }
  if (job->taskid > 9 && job->taskid < 100) {
  strcat(tmp1,yy);
  tmp2 = tmp1;
 }

  strcat(xx, tmp2);
  //fprintf(file.out,"%s\n",xx) ;
  strcat(zz,tmp2);
  //fprintf(file.out,"%s\n",xx) ;
  strcat(xx,zz);
  //strcat(xx, tmp2);
  //fprintf(file.out,"%s\n",xx) ;

  test = system(xx);

  if (test) {

    fprintf(stderr, "ERROR: BAND run for block %d unsuccessfully \n", kk);
    fprintf(file.err, "ERROR1: BAND run for block %d unsuccessfully \n", kk);
    fclose(file.out);
    fclose(file.err);
    exit(1);

  }

  printf(" BAND run for block %d  successfully \n", kk);

  return;
}

void write_vectors_get_values(int *isv, int nkunique, VECTOR_KNET *knet, int *bands, double *eigval, ATOM *atoms, JOB_PARAM *job, FILES file)

{

  int i, j, k, l, nbands = bands[1] - bands[0] + 1;
  int dim1, dim2, k_count, block_size, vector_size;
  int nloop, nkloop, nk, nkpt;
  int *latt;
  int begin_k[job->numtasks], end_k[job->numtasks] ;
  int receive_k[job->numtasks], offset_k[job->numtasks] ;
  int receive_e[job->numtasks], offset_e[job->numtasks] ;
  double *akv, *eigenvector;
  MPI_File fh ;

  //nloop = (MEM_REQR+MEM_REQK)/MEM_SIZE ; if (nloop == 0) nloop = 1 ;
  nloop = 1;
  if (job->verbosity > 1)
  fprintf(file.out,"nloop %3d\n",nloop) ;

  int begin_k_local[nloop], end_k_local[nloop] ;

  mpi_begin_end(begin_k,end_k,nkunique,job->numtasks,job,file);
  mpi_receive_offset(begin_k,end_k,receive_k,offset_k,nbands,job,file);
  mpi_receive_offset(begin_k,end_k,receive_e,offset_e,nbands * atoms->number_of_sh_bfns_in_unit_cell,job,file);
  mpi_local_begin_end(nloop,begin_k,end_k,begin_k_local,end_k_local,job,file);
  nk = end_k[job->taskid] - begin_k[job->taskid] ;

  char xx[4], eigenvec_1[] = "EIGENVEC.1.", eigenvec_2[] = "EIGENVEC.2.";
  char tmp[8] = "00", tmp1[8] = "0", *tmp2, zz[4];
  //char tmp[] = "00", tmp1[] = "0", *tmp2, zz[4];
  char h[] = "/home/tsphy/cpttrson/Crystal03/calcs/Si_Pascale/datafile";
  char d[] = "datafile";

  sprintf(zz, "%d", job->taskid);
  if (job->taskid < 10) {
  strcat(tmp,zz);
  tmp2 = tmp;
 }
  if (job->taskid > 9 && job->taskid < 100) {
  strcat(tmp1,zz);
  tmp2 = tmp1;
 }

  strcat(eigenvec_1, tmp2);
  strcat(eigenvec_2, tmp2);

  size_t size = 100;
  char *g, *buf, buf1[100], yy[10] = "/datafile";
  buf = buf1;
  buf = getcwd(buf,size);
  strcat(buf1,yy);
  g = buf1;

  if (job->numtasks == 1)
  MPI_File_open(MPI_COMM_WORLD,d,MPI_MODE_RDWR | MPI_MODE_CREATE,MPI_INFO_NULL,&fh) ;
  if (job->numtasks > 1)
  MPI_File_open(MPI_COMM_WORLD,h,MPI_MODE_RDWR | MPI_MODE_CREATE,MPI_INFO_NULL,&fh) ;

 akv = (double *) malloc(2 * atoms->number_of_sh_bfns_in_unit_cell * atoms->number_of_sh_bfns_in_unit_cell * sizeof(double));
  if (akv == NULL) { fprintf(stderr, "ERROR: not enough memory for double akv! \n"); exit(1); }

  vector_size = nbands * atoms->number_of_sh_bfns_in_unit_cell;
  block_size = vector_size * sizeof(Complex);

  k_count = 0;

  for (l = 0; l < nloop; l++) {

  nkpt = end_k_local[l] - begin_k_local[l];
  int kk[nkpt][3];

  latt = (int *) malloc(nkpt * sizeof(int));
  if (latt == NULL) { fprintf(stderr, "ERROR: not enough memory for int latt! \n"); exit(1); }

  eigenvector = (double *) malloc(2 * nkpt * vector_size * sizeof(double));
  if (eigenvector == NULL) { fprintf(stderr, "ERROR: not enough memory for double eigenvector! \n"); exit(1); }

  FILE *band_gen;
  char yy[] = "band.gen.";
  band_gen = fopen(strcat(yy, tmp2), "w");
  //band_gen = fopen(strcat(yy, xx), "w");
  if (band_gen == NULL) { fprintf(stderr, "ERROR: Cannot open file 'band.gen'. \n"); exit(1); }

  fprintf(band_gen, "XCBD\n");
  fprintf(band_gen, "1  2  1 %s\n",tmp2);
  //fprintf(band_gen, "1  2  1%3d\n", job->taskid);
  fprintf(band_gen, "%5d %4d %4d\n", isv[0], isv[1], isv[2]);
  fprintf(band_gen, "%5d\n", nkpt);
  for (i = begin_k_local[l]; i < end_k_local[l]; i++)
  fprintf(band_gen, "%4d %4d %4d\n", knet[i].oblique.comp1, knet[i].oblique.comp2, knet[i].oblique.comp3);
  fprintf(band_gen, "0\n");
  fprintf(band_gen, "END\n");
  fprintf(band_gen, "END\n");
  fflush(band_gen);

  run_properties(3, 1, 0, job, file);
  dim1= offset_k[job->taskid] + k_count * nbands;
  dim2 = dim1 + nkunique * nbands;
  read_evalues(nkpt, bands, latt, kk, &eigval[offset_k[job->taskid] + k_count * nbands], \
  &eigval[offset_k[job->taskid] + (nkunique + k_count) * nbands], atoms, job, file);
  read_evectors(nkpt, bands, latt, akv, eigenvector, eigenvec_1, atoms, job, file);
  MPI_File_seek(fh, offset_e[job->taskid] * sizeof(Complex) + k_count * block_size, MPI_SEEK_SET) ;
  MPI_File_write(fh, eigenvector, 2 * nkpt * vector_size, MPI_DOUBLE, MPI_STATUS_IGNORE);
  if (job->spin_polarisation == 1) {
  read_evectors(nkpt, bands, latt, akv, eigenvector, eigenvec_2, atoms, job, file);
  MPI_File_seek(fh, offset_e[job->taskid] * sizeof(Complex) + (nkunique + k_count) * block_size, MPI_SEEK_SET) ;
  MPI_File_write(fh, eigenvector, 2 * nkpt * vector_size, MPI_DOUBLE, MPI_STATUS_IGNORE);
 }

  free(latt);
  free(eigenvector);

  k_count += nkpt;

  } // close loop on l

  free(akv);

  MPI_File_close(&fh) ;
  MPI_Barrier(MPI_COMM_WORLD);

  MPI_Allgatherv(&eigval[offset_k[job->taskid]], receive_k[job->taskid], MPI_DOUBLE, eigval, receive_k, offset_k,
  MPI_DOUBLE, MPI_COMM_WORLD);
  if (job->spin_polarisation == 1) {
  dim1 = nkunique * nbands;
  MPI_Allgatherv(&eigval[dim1 + offset_k[job->taskid]], receive_k[job->taskid], MPI_DOUBLE, &eigval[dim1], receive_k, offset_k,  MPI_DOUBLE, MPI_COMM_WORLD);
 }


}

void write_vectors_write_values_rma(int *isv, int nkunique, VECTOR_KNET *knet, int *bands, double *eigval, ATOM *atoms, JOB_PARAM *job, FILES file)

{

  int i, j, k, l, nbands = bands[1] - bands[0] + 1;
  int block_size, vector_size;
  int nloop, nkpt;
  int *latt;
  int begin_k, end_k ;
  int offset_e, offset_k ;
  int *counter, winRank, myCounter, increment, end;
  double *akv, *eigenvector;
  const int izero = 0;
  MPI_File fh, gh;
  MPI_Win win;

  char xx[4], eigenvec_1[] = "EIGENVEC.1.", eigenvec_2[] = "EIGENVEC.2.";
  char tmp[8] = "00", tmp1[8] = "0", *tmp2, zz[4];
  //char tmp[] = "00", tmp1[] = "0", *tmp2, zz[4];
  char c[] = "evalfile";
  char d[] = "datafile";
  char f[] = "/home/tsphy/cpttrson/Crystal03/calcs/Si_Pascale/datafile";
  char h[] = "/home/tsphy/cpttrson/Crystal03/calcs/Si_Pascale/evalfile";

  sprintf(zz, "%d", job->taskid);
  if (job->taskid < 10) {
  strcat(tmp,zz);
  tmp2 = tmp;
 }
  if (job->taskid > 9 && job->taskid < 100) {
  strcat(tmp1,zz);
  tmp2 = tmp1;
 }

  strcat(eigenvec_1, tmp2);
  strcat(eigenvec_2, tmp2);

  size_t size = 100;
  char *g, *buf, buf1[100], yy[10] = "/datafile";
  buf = buf1;
  buf = getcwd(buf,size);
  strcat(buf1,yy);
  g = buf1;

  if (job->numtasks == 1)
  MPI_File_open(MPI_COMM_WORLD,d,MPI_MODE_RDWR | MPI_MODE_CREATE,MPI_INFO_NULL,&fh) ;
  if (job->numtasks == 1)
  MPI_File_open(MPI_COMM_WORLD,c,MPI_MODE_RDWR | MPI_MODE_CREATE,MPI_INFO_NULL,&gh) ;
  if (job->numtasks > 1)
  MPI_File_open(MPI_COMM_WORLD,f,MPI_MODE_RDWR | MPI_MODE_CREATE,MPI_INFO_NULL,&fh) ;
  if (job->numtasks > 1)
  MPI_File_open(MPI_COMM_WORLD,h,MPI_MODE_RDWR | MPI_MODE_CREATE,MPI_INFO_NULL,&gh) ;

 akv = (double *) malloc(2 * atoms->number_of_sh_bfns_in_unit_cell * atoms->number_of_sh_bfns_in_unit_cell * sizeof(double));
  if (akv == NULL) { fprintf(stderr, "ERROR: not enough memory for double akv! \n"); exit(1); }

  vector_size = nbands * atoms->number_of_sh_bfns_in_unit_cell;
  block_size = vector_size * sizeof(Complex);

  winRank=0;
  CreateCounter(job->taskid, winRank, &counter, izero, &win, MPI_COMM_WORLD);
  myCounter = 0;

  while (1) {
    increment = (nkunique - myCounter) / job->numtasks / 2;
    if (increment < 1) increment = 1;
    myCounter = GetCounter(winRank, increment , &win);
    if (myCounter >= nkunique) break;
    end =  (myCounter + increment < nkunique) ? myCounter + increment : nkunique;
    //end =  (myCounter + increment < nkunique) ? myCounter + increment - 1 : nkunique;
    printf("Process %d obtained the following task(s): %d %d %d %d\n", job->taskid, myCounter, end, \
    myCounter + increment - 1, nkunique);
    begin_k = myCounter;
    end_k   = end;

  //nloop = (MEM_REQR+MEM_REQK)/MEM_SIZE ; if (nloop == 0) nloop = 1 ;
  nloop = 1;
  if (job->verbosity > 1)
  fprintf(file.out,"nloop %3d\n",nloop) ;

  nkpt = end_k - begin_k;
  int kk[nkpt][3];
  //nkpt = end_k - begin_k + 1;
  offset_e  = begin_k * nbands * atoms->number_of_sh_bfns_in_unit_cell;
  offset_k  = begin_k * nbands;
  //fprintf(file.out,"begin_k %d end_k %d, nkpt %d offset_e %d offset_k %d\n",begin_k,end_k,nkpt,offset_e,offset_k);

  latt = (int *) malloc(nkpt * sizeof(int));
  if (latt == NULL) { fprintf(stderr, "ERROR: not enough memory for int latt! \n"); exit(1); }

  eigenvector = (double *) malloc(2 * nkpt * vector_size * sizeof(double));
  if (eigenvector == NULL) { fprintf(stderr, "ERROR: not enough memory for double eigenvector! \n"); exit(1); }

  FILE *band_gen;
  char yy[] = "band.gen.";
  band_gen = fopen(strcat(yy, tmp2), "w");
  if (band_gen == NULL) { fprintf(stderr, "ERROR: Cannot open file 'band.gen'. \n"); exit(1); }

  fprintf(band_gen, "XCBD\n");
  fprintf(band_gen, "1  2  1 %s\n",tmp2);
  fprintf(band_gen, "%5d %4d %4d\n", isv[0], isv[1], isv[2]);
  fprintf(band_gen, "%5d\n", nkpt);
  for (i = begin_k; i < end_k; i++)
  //for (i = begin_k; i <= end_k; i++)
  fprintf(band_gen, "%4d %4d %4d\n", knet[i].oblique.comp1, knet[i].oblique.comp2, knet[i].oblique.comp3);
  fprintf(band_gen, "0\n");
  fprintf(band_gen, "END\n");
  fprintf(band_gen, "END\n");
  fflush(band_gen);

  run_properties(3, 1, 0, job, file);

  read_evalues(nkpt, bands, latt, kk, &eigval[0], &eigval[nkpt * nbands], atoms, job, file);
  MPI_File_seek(gh, offset_k * sizeof(double), MPI_SEEK_SET) ;
  MPI_File_write(gh, eigval, nkpt * nbands, MPI_DOUBLE, MPI_STATUS_IGNORE);

  read_evectors(nkpt, bands, latt, akv, eigenvector, eigenvec_1, atoms, job, file);
  MPI_File_seek(fh, offset_e * sizeof(Complex), MPI_SEEK_SET) ;
  MPI_File_write(fh, eigenvector, 2 * nkpt * vector_size, MPI_DOUBLE, MPI_STATUS_IGNORE);

  if (job->spin_polarisation == 1) {

  MPI_File_seek(gh, (nkunique * nbands + offset_k) * sizeof(double), MPI_SEEK_SET) ;
  MPI_File_write(gh, &eigval[nkpt * nbands], nkpt * nbands, MPI_DOUBLE, MPI_STATUS_IGNORE);

  read_evectors(nkpt, bands, latt, akv, eigenvector, eigenvec_2, atoms, job, file);
  MPI_File_seek(fh, offset_e * sizeof(Complex) + nkunique * block_size, MPI_SEEK_SET) ;
  MPI_File_write(fh, eigenvector, 2 * nkpt * vector_size, MPI_DOUBLE, MPI_STATUS_IGNORE);
 }

  free(latt);
  free(eigenvector);

  }

  free(akv);
  DestroyCounter(job->taskid, winRank, &win, counter);
  MPI_File_close(&fh) ;
  MPI_File_close(&gh) ;

}

void write_vectors_write_values_rma1(int *isv, int nkunique, KPOINT_TRAN *knet, int *bands, ATOM *atoms, JOB_PARAM *job, FILES file)

{

  int i, j, k, l, nbands = bands[1] - bands[0] + 1;
  int block_size, vector_size;
  int nloop, nkpt;
  int *latt;
  int begin_k, end_k ;
  int offset_e, offset_k ;
  int *counter, winRank, myCounter, increment, end;
  double *akv, *eigval, *eigenvector;
  const int izero = 0;
  MPI_File fh, gh;
  MPI_Win win;

  char eigenvec_1[15] = "EIGENVEC.1.", eigenvec_2[15] = "EIGENVEC.2.";
  char tmp[4] = "00", tmp1[4] = "0", *tmp2, zz[4];

  sprintf(zz, "%d", job->taskid);
  if (job->taskid < 10) {
  strcat(tmp,zz);
  tmp2 = tmp;
 }

  if (job->taskid > 9 && job->taskid < 100) {
  strcat(tmp1,zz);
  tmp2 = tmp1;
 }

  strcat(eigenvec_1, tmp2);
  strcat(eigenvec_2, tmp2);

  char buf2[110], buf3[110];
  char zz1[10] = "/evalfile", yy[10] = "/datafile";;

  strcpy(buf2,file.directory1);
  strcat(buf2,yy);
  strcpy(buf3,file.directory1);
  strcat(buf3,zz1);

  MPI_File_open(MPI_COMM_WORLD,buf2,MPI_MODE_RDWR | MPI_MODE_CREATE,MPI_INFO_NULL,&fh) ;
  MPI_File_open(MPI_COMM_WORLD,buf3,MPI_MODE_RDWR | MPI_MODE_CREATE,MPI_INFO_NULL,&gh) ;

 akv = (double *) malloc(2 * atoms->number_of_sh_bfns_in_unit_cell * atoms->number_of_sh_bfns_in_unit_cell * sizeof(double));
  if (akv == NULL) { fprintf(stderr, "ERROR: not enough memory for double akv! \n"); exit(1); }

  vector_size = nbands * atoms->number_of_sh_bfns_in_unit_cell;
  block_size = vector_size * sizeof(Complex);

  winRank=0;
  CreateCounter(job->taskid, winRank, &counter, izero, &win, MPI_COMM_WORLD);
  myCounter = 0;

  while (1) {
    increment = (nkunique - myCounter) / job->numtasks / 2;
    if (increment <  1) increment =  1;
    if (increment > 64) increment = 64;
    myCounter = GetCounter(winRank, increment , &win);
    if (myCounter >= nkunique) break;
    end =  (myCounter + increment < nkunique) ? myCounter + increment : nkunique;
    //end =  (myCounter + increment < nkunique) ? myCounter + increment - 1 : nkunique;
    printf("Process %d obtained the following task(s): %d %d %d %d\n", job->taskid, myCounter, end, \
    myCounter + increment - 1, nkunique);
    begin_k = myCounter;
    end_k   = end;

  //nloop = (MEM_REQR+MEM_REQK)/MEM_SIZE ; if (nloop == 0) nloop = 1 ;
  nloop = 1;
  if (job->verbosity > 1)
  fprintf(file.out,"nloop %3d\n",nloop) ;

  nkpt = end_k - begin_k;
  int kk[nkpt][3];
  //nkpt = end_k - begin_k + 1;
  offset_e  = begin_k * nbands * atoms->number_of_sh_bfns_in_unit_cell;
  offset_k  = begin_k * nbands;
  if (job->verbosity > 1)
  fprintf(file.out,"begin_k %d end_k %d, nkpt %d offset_e %d offset_k %d\n",begin_k,end_k,nkpt,offset_e,offset_k);

  latt = (int *) malloc(nkpt * sizeof(int));
  if (latt == NULL) { fprintf(stderr, "ERROR: not enough memory for int latt! \n"); exit(1); }

  eigval = (double *) malloc(job->spin_dim * nkpt * nbands * sizeof(double));
  if (eigval == NULL) { fprintf(stderr, "ERROR: not enough memory for double eigval! \n"); exit(1); }

  eigenvector = (double *) malloc(2 * nkpt * vector_size * sizeof(double));
  if (eigenvector == NULL) { fprintf(stderr, "ERROR: not enough memory for double eigenvector! \n"); exit(1); }

  FILE *band_gen;
  char yy[] = "band.gen.";
  band_gen = fopen(strcat(yy, tmp2), "w");
  if (band_gen == NULL) { fprintf(stderr, "ERROR: Cannot open file 'band.gen'. \n"); exit(1); }

  fprintf(band_gen, "XCBD\n");
  fprintf(band_gen, "1  2  1 %s\n",tmp2);
  fprintf(band_gen, "%5d %4d %4d\n", isv[0], isv[1], isv[2]);
  fprintf(band_gen, "%5d\n", nkpt);
  for (i = begin_k; i < end_k; i++) {
  j = knet->ibz[i];
  fprintf(band_gen, "%4d %4d %4d\n", knet->oblique[j].comp1, knet->oblique[j].comp2, knet->oblique[j].comp3); }
  fprintf(band_gen, "0\n");
  fprintf(band_gen, "END\n");
  fprintf(band_gen, "END\n");
  fflush(band_gen);

  run_properties(3, 1, 0, job, file);

  read_evalues(nkpt, bands, latt, kk, &eigval[0], &eigval[nkpt * nbands], atoms, job, file);
  MPI_File_seek(gh, offset_k * sizeof(double), MPI_SEEK_SET) ;
  MPI_File_write(gh, eigval, nkpt * nbands, MPI_DOUBLE, MPI_STATUS_IGNORE);

  read_evectors(nkpt, bands, latt, akv, eigenvector, eigenvec_1, atoms, job, file);
  MPI_File_seek(fh, offset_e * sizeof(Complex), MPI_SEEK_SET) ;
  MPI_File_write(fh, eigenvector, 2 * nkpt * vector_size, MPI_DOUBLE, MPI_STATUS_IGNORE);

  if (job->spin_polarisation == 1) {

  MPI_File_seek(gh, (nkunique * nbands + offset_k) * sizeof(double), MPI_SEEK_SET) ;
  MPI_File_write(gh, &eigval[nkpt * nbands], nkpt * nbands, MPI_DOUBLE, MPI_STATUS_IGNORE);

  read_evectors(nkpt, bands, latt, akv, eigenvector, eigenvec_2, atoms, job, file);
  MPI_File_seek(fh, offset_e * sizeof(Complex) + nkunique * block_size, MPI_SEEK_SET) ;
  MPI_File_write(fh, eigenvector, 2 * nkpt * vector_size, MPI_DOUBLE, MPI_STATUS_IGNORE);
 }

  free(latt);
  free(eigval);
  free(eigenvector);

  }

  free(akv);
  DestroyCounter(job->taskid, winRank, &win, counter);

  MPI_File_close(&fh) ;
  MPI_File_close(&gh) ;

  MPI_Barrier(MPI_COMM_WORLD);

}

void write_vectors_write_values_rma2(int *isv, int nkunique, KPOINT_TRAN *knet, int *bands, ATOM *atoms, SYMMETRY *symmetry, CRYSTAL *crystal, JOB_PARAM *job, FILES file)

{

  int nbands = bands[1] - bands[0] + 1;
  int block_size, vector_size;
  int nktot = isv[0] * isv[1] * isv[2];
  int kk[nkunique][3];
  int k1[nktot][3];
  int *latt, *latt_full;

  double *akv, *eigval, *eigenvector;
  MPI_File fh, gh;

  char eigenvec_1[15] = "EIGENVEC.1.";
  char tmp[4] = "00", tmp1[4] = "0", *tmp2, zz[4];

  sprintf(zz, "%d", job->taskid);
  if (job->taskid < 10) {
  strcat(tmp,zz);
  tmp2 = tmp;
 }

  if (job->taskid > 9 && job->taskid < 100) {
  strcat(tmp1,zz);
  tmp2 = tmp1;
 }

  strcat(eigenvec_1, tmp2);

  char buf2[110], buf3[110];
  char zz1[10] = "/evalfile", yy[10] = "/datafile";

  strcpy(buf2,file.directory1);
  strcat(buf2,yy);
  strcpy(buf3,file.directory1);
  strcat(buf3,zz1);

  MPI_File_open(MPI_COMM_WORLD,buf2,MPI_MODE_RDWR | MPI_MODE_CREATE,MPI_INFO_NULL,&fh) ;
  MPI_File_open(MPI_COMM_WORLD,buf3,MPI_MODE_RDWR | MPI_MODE_CREATE,MPI_INFO_NULL,&gh) ;

  akv = (double *) malloc(2 * atoms->number_of_sh_bfns_in_unit_cell * atoms->number_of_sh_bfns_in_unit_cell * sizeof(double));
  if (akv == NULL) { fprintf(stderr, "ERROR: not enough memory for double akv! \n"); exit(1); }

  vector_size = nbands * atoms->number_of_sh_bfns_in_unit_cell;
  block_size = vector_size * sizeof(Complex);

  latt = (int *) malloc(nkunique * sizeof(int));
  if (latt == NULL) { fprintf(stderr, "ERROR: not enough memory for int latt! \n"); exit(1); }

  latt_full = (int *) malloc(nktot * sizeof(int));
  if (latt_full == NULL) { fprintf(stderr, "ERROR: not enough memory for int latt_full! \n"); exit(1); }

  eigval = (double *) malloc(job->spin_dim * nkunique * nbands * sizeof(double));
  if (eigval == NULL) { fprintf(stderr, "ERROR: not enough memory for double eigval! \n"); exit(1); }

  eigenvector = (double *) malloc(job->spin_dim * 2 * nktot * vector_size * sizeof(double));
  if (eigenvector == NULL) { fprintf(stderr, "ERROR: not enough memory for double eigenvector! \n"); exit(1); }

  read_evalues_crystal_09(nkunique, nktot, bands, latt, latt_full, kk, k1, &eigval[0], &eigval[nkunique * nbands], atoms, job, file);

  MPI_File_seek(gh, 0, MPI_SEEK_SET) ;
  MPI_File_write(gh, eigval, nkunique * nbands, MPI_DOUBLE, MPI_STATUS_IGNORE);

  read_evectors_crystal_09(knet, nkunique, k1, isv, bands, latt, akv, eigenvector, eigenvec_1, atoms, job, file);

  MPI_File_seek(fh, 0, MPI_SEEK_SET) ;
  MPI_File_write(fh, eigenvector, job->spin_dim * 2 * nkunique * vector_size, MPI_DOUBLE, MPI_STATUS_IGNORE);

  free(akv);
  free(latt);
  free(latt_full);
  free(eigval);
  free(eigenvector);

  MPI_File_close(&fh) ;
  MPI_File_close(&gh) ;

  MPI_Barrier(MPI_COMM_WORLD);

}

void write_vectors_rma1(int *isv, int nkunique, KPOINT_TRAN *knet, int *bands, ATOM *atoms, JOB_PARAM *job, FILES file)

{

fprintf(file.out,"Bug in write_vectors_rma1 somewhere\n");

MPI_Finalize();
exit(0);

  int i, j, k, l, nbands = bands[1] - bands[0] + 1;
  int block_size, vector_size;
  int nloop, nkpt;
  int *latt;
  int begin_k, end_k ;
  int offset_e ;
  int *counter, winRank, myCounter, increment, end;
  double *akv, *eigenvector;
  const int izero = 0;
  MPI_File fh;
  MPI_Win win;

  char eigenvec_1[15] = "EIGENVEC.1.", eigenvec_2[15] = "EIGENVEC.2.";
  char tmp[4] = "00", tmp1[4] = "0", *tmp2, zz[4];

  sprintf(zz, "%d", job->taskid);
  if (job->taskid < 10) {
  strcat(tmp,zz);
  tmp2 = tmp;
 }

  if (job->taskid > 9 && job->taskid < 100) {
  strcat(tmp1,zz);
  tmp2 = tmp1;
 }

  strcat(eigenvec_1, tmp2);
  strcat(eigenvec_2, tmp2);

  char buf2[110];
  char yy[10] = "/datafile";;

  strcpy(buf2,file.directory1);
  strcat(buf2,yy);

  MPI_File_open(MPI_COMM_WORLD,buf2,MPI_MODE_RDWR | MPI_MODE_CREATE,MPI_INFO_NULL,&fh) ;

 akv = (double *) malloc(2 * atoms->number_of_sh_bfns_in_unit_cell * atoms->number_of_sh_bfns_in_unit_cell * sizeof(double));
  if (akv == NULL) { fprintf(stderr, "ERROR: not enough memory for double akv! \n"); exit(1); }

  vector_size = nbands * atoms->number_of_sh_bfns_in_unit_cell;
  block_size = vector_size * sizeof(Complex);

  winRank=0;
  CreateCounter(job->taskid, winRank, &counter, izero, &win, MPI_COMM_WORLD);
  myCounter = 0;

  while (1) {
    increment = (nkunique - myCounter) / job->numtasks / 2;
    if (increment <  1) increment =  1;
    if (increment > 64) increment = 64;
    myCounter = GetCounter(winRank, increment , &win);
    if (myCounter >= nkunique) break;
    end =  (myCounter + increment < nkunique) ? myCounter + increment : nkunique;
    //end =  (myCounter + increment < nkunique) ? myCounter + increment - 1 : nkunique;
    printf("Process %d obtained the following task(s): %d %d %d %d\n", job->taskid, myCounter, end, \
    myCounter + increment - 1, nkunique);
    begin_k = myCounter;
    end_k   = end;

  //nloop = (MEM_REQR+MEM_REQK)/MEM_SIZE ; if (nloop == 0) nloop = 1 ;
  nloop = 1;
  if (job->verbosity > 1)
  fprintf(file.out,"nloop %3d\n",nloop) ;

  nkpt = end_k - begin_k;
  offset_e  = begin_k * nbands * atoms->number_of_sh_bfns_in_unit_cell;
  if (job->verbosity > 1)
  fprintf(file.out,"begin_k %d end_k %d, nkpt %d offset_e %d\n",begin_k,end_k,nkpt,offset_e);

  latt = (int *) malloc(nkpt * sizeof(int));
  if (latt == NULL) { fprintf(stderr, "ERROR: not enough memory for int latt! \n"); exit(1); }

  eigenvector = (double *) malloc(2 * nkpt * vector_size * sizeof(double));
  if (eigenvector == NULL) { fprintf(stderr, "ERROR: not enough memory for double eigenvector! \n"); exit(1); }

  FILE *band_gen;
  char yy[] = "band.gen.";
  band_gen = fopen(strcat(yy, tmp2), "w");
  if (band_gen == NULL) { fprintf(stderr, "ERROR: Cannot open file 'band.gen'. \n"); exit(1); }

  fprintf(band_gen, "XCBD\n");
  fprintf(band_gen, "1  2  1 %s\n",tmp2);
  fprintf(band_gen, "%5d %4d %4d\n", isv[0], isv[1], isv[2]);
  fprintf(band_gen, "%5d\n", nkpt);
  for (i = begin_k; i < end_k; i++) {
  j = knet->ibz[i];
  fprintf(band_gen, "%4d %4d %4d\n", knet->oblique[j].comp1, knet->oblique[j].comp2, knet->oblique[j].comp3); }
  fprintf(band_gen, "0\n");
  fprintf(band_gen, "END\n");
  fprintf(band_gen, "END\n");
  fflush(band_gen);

  run_properties(3, 1, 0, job, file);

  read_evectors(nkpt, bands, latt, akv, eigenvector, eigenvec_1, atoms, job, file);
  MPI_File_seek(fh, offset_e * sizeof(Complex), MPI_SEEK_SET) ;
  MPI_File_write(fh, eigenvector, 2 * nkpt * vector_size, MPI_DOUBLE, MPI_STATUS_IGNORE);

  if (job->spin_polarisation == 1) {

  read_evectors(nkpt, bands, latt, akv, eigenvector, eigenvec_2, atoms, job, file);
  MPI_File_seek(fh, offset_e * sizeof(Complex) + nkunique * block_size, MPI_SEEK_SET) ;
  MPI_File_write(fh, eigenvector, 2 * nkpt * vector_size, MPI_DOUBLE, MPI_STATUS_IGNORE);
 }

  free(latt);
  free(eigenvector);

  }

  free(akv);
  DestroyCounter(job->taskid, winRank, &win, counter);

  MPI_File_close(&fh) ;

  MPI_Barrier(MPI_COMM_WORLD);

}

void write_values_rma1(int *isv, int nkunique, KPOINT_TRAN *knet, int *bands, ATOM *atoms, JOB_PARAM *job, FILES file)

{

  int i, j, k, l, nbands = bands[1] - bands[0] + 1;
  int nloop, nkpt;
  int *latt;
  int begin_k, end_k ;
  int offset_e, offset_k ;
  int *counter, winRank, myCounter, increment, end;
  double *eigval;
  const int izero = 0;
  MPI_File gh;
  MPI_Win win;

  char tmp[4] = "00", tmp1[4] = "0", *tmp2, zz[4];

  sprintf(zz, "%d", job->taskid);
  if (job->taskid < 10) {
  strcat(tmp,zz);
  tmp2 = tmp;
 }

  if (job->taskid > 9 && job->taskid < 100) {
  strcat(tmp1,zz);
  tmp2 = tmp1;
 }

  char buf3[110];
  char zz1[10] = "/evalfile";
  strcpy(buf3,file.directory1);
  strcat(buf3,zz1);

  MPI_File_open(MPI_COMM_WORLD,buf3,MPI_MODE_RDWR | MPI_MODE_CREATE,MPI_INFO_NULL,&gh) ;

  winRank=0;
  CreateCounter(job->taskid, winRank, &counter, izero, &win, MPI_COMM_WORLD);
  myCounter = 0;

  while (1) {
    increment = (nkunique - myCounter) / job->numtasks / 2;
    if (increment <  1) increment =  1;
    if (increment > 64) increment = 64;
    myCounter = GetCounter(winRank, increment , &win);
    if (myCounter >= nkunique) break;
    end =  (myCounter + increment < nkunique) ? myCounter + increment : nkunique;
    //end =  (myCounter + increment < nkunique) ? myCounter + increment - 1 : nkunique;
    printf("Process %d obtained the following task(s): %d %d %d %d\n", job->taskid, myCounter, end, \
    myCounter + increment - 1, nkunique);
    begin_k = myCounter;
    end_k   = end;

  //nloop = (MEM_REQR+MEM_REQK)/MEM_SIZE ; if (nloop == 0) nloop = 1 ;
  nloop = 1;
  if (job->verbosity > 1)
  fprintf(file.out,"nloop %3d\n",nloop) ;

  nkpt = end_k - begin_k;
  int kk[nkpt][3];
  offset_k  = begin_k * nbands;
  if (job->verbosity > 1)
  fprintf(file.out,"begin_k %d end_k %d, nkpt %d offset_e %d offset_k %d\n",begin_k,end_k,nkpt,offset_e,offset_k);

  latt = (int *) malloc(nkpt * sizeof(int));
  if (latt == NULL) { fprintf(stderr, "ERROR: not enough memory for int latt! \n"); exit(1); }

  eigval = (double *) malloc(job->spin_dim * nkpt * nbands * sizeof(double));
  if (eigval == NULL) { fprintf(stderr, "ERROR: not enough memory for double eigval! \n"); exit(1); }

  FILE *band_gen;
  char yy[] = "band.gen.";
  band_gen = fopen(strcat(yy, tmp2), "w");
  if (band_gen == NULL) { fprintf(stderr, "ERROR: Cannot open file 'band.gen'. \n"); exit(1); }

  fprintf(band_gen, "XCBD\n");
  fprintf(band_gen, "1  2  1 %s\n",tmp2);
  fprintf(band_gen, "%5d %4d %4d\n", isv[0], isv[1], isv[2]);
  fprintf(band_gen, "%5d\n", nkpt);
  for (i = begin_k; i < end_k; i++) {
  j = knet->ibz[i];
  fprintf(band_gen, "%4d %4d %4d\n", knet->oblique[j].comp1, knet->oblique[j].comp2, knet->oblique[j].comp3); }
  fprintf(band_gen, "0\n");
  fprintf(band_gen, "END\n");
  fprintf(band_gen, "END\n");
  fflush(band_gen);

  run_properties(3, 1, 0, job, file);

  read_evalues(nkpt, bands, latt, kk, &eigval[0], &eigval[nkpt * nbands], atoms, job, file);
  MPI_File_seek(gh, offset_k * sizeof(double), MPI_SEEK_SET) ;
  MPI_File_write(gh, eigval, nkpt * nbands, MPI_DOUBLE, MPI_STATUS_IGNORE);

  if (job->spin_polarisation == 1) {

  MPI_File_seek(gh, (nkunique * nbands + offset_k) * sizeof(double), MPI_SEEK_SET) ;
  MPI_File_write(gh, &eigval[nkpt * nbands], nkpt * nbands, MPI_DOUBLE, MPI_STATUS_IGNORE);

 }

  free(latt);
  free(eigval);

  }

  DestroyCounter(job->taskid, winRank, &win, counter);

  MPI_File_close(&gh) ;

  MPI_Barrier(MPI_COMM_WORLD);

}

*/
